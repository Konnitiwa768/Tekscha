<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>PvPテクスチャエディタ</title>
<style>
  body { font-family: sans-serif; padding: 20px; background: #222; color: #eee; }
  canvas { border: 1px solid #888; image-rendering: pixelated; }
  input, button { margin: 5px 0; display: block; }
</style>
</head>
<body>

<h2>PvPテクスチャエディタ</h2>

<!-- GitHub情報 -->
<label>GitHub Token: <input type="password" id="token"></label>
<label>ユーザー名: <input type="text" id="user"></label>
<label>リポジトリ名: <input type="text" id="repo"></label>
<label>ディレクトリ名: <input type="text" id="dir"></label>

<!-- キャンバス操作 -->
<label>キャンバス幅: <input type="number" id="width" value="64"></label>
<label>キャンバス高さ: <input type="number" id="height" value="64"></label>
<button id="create">キャンバス作成</button>
<input type="file" id="fileInput">

<!-- テンプレート -->
<button id="template">テンプレートを読み込む</button>
<input type="file" id="templateFile">

<!-- ブラシ設定 -->
<label>ブラシカラー: <input type="color" id="color" value="#ff0000"></label>
<label>透明ブラシ: <input type="checkbox" id="eraser"></label>

<!-- 色調整 -->
<label>彩度: <input type="range" id="saturation" min="-100" max="100" value="0"></label>
<label>明度: <input type="range" id="brightness" min="-100" max="100" value="0"></label>
<label>色相: <input type="range" id="hue" min="0" max="360" value="0"></label>

<!-- ローカル保存 -->
<button id="saveLocal">ローカル保存</button>
<button id="loadLocal">ローカル読み込み</button>

<!-- アップロード -->
<label>ファイル名: <input type="text" id="filename" value="texture.png"></label>
<button id="upload">GitHubにアップロード</button>

<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let drawing = false;

// ブラシ描画
const colorInput = document.getElementById('color');
const eraserInput = document.getElementById('eraser');

canvas.addEventListener('mousedown', e => { drawing = true; draw(e); });
canvas.addEventListener('mouseup', () => { drawing = false; });
canvas.addEventListener('mousemove', draw);

function draw(e) {
  if (!drawing) return;
  const rect = canvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) * (canvas.width / rect.width));
  const y = Math.floor((e.clientY - rect.top) * (canvas.height / rect.height));
  ctx.fillStyle = eraserInput.checked ? 'rgba(0,0,0,0)' : colorInput.value;
  ctx.globalCompositeOperation = eraserInput.checked ? 'destination-out' : 'source-over';
  ctx.fillRect(x, y, 1, 1);
}

// キャンバス作成
document.getElementById('create').onclick = () => {
  const w = parseInt(document.getElementById('width').value);
  const h = parseInt(document.getElementById('height').value);
  canvas.width = w;
  canvas.height = h;
  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0,0,w,h); // 完全透明
};

// 画像読み込み
document.getElementById('fileInput').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  img.src = URL.createObjectURL(file);
});

// テンプレート読み込み
document.getElementById('template').onclick = () => document.getElementById('templateFile').click();
document.getElementById('templateFile').addEventListener('change', e => {
  const file = e.target.files[0];
  if (!file) return;
  const img = new Image();
  img.onload = () => {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img,0,0,canvas.width,canvas.height);
  };
  img.src = URL.createObjectURL(file);
});

// 色調整
['saturation', 'brightness', 'hue'].forEach(id => document.getElementById(id).addEventListener('input', applyFilters));

function applyFilters() {
  const sat = parseInt(document.getElementById('saturation').value);
  const bright = parseInt(document.getElementById('brightness').value);
  const hue = parseInt(document.getElementById('hue').value);
  
  const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const data = imgData.data;
  
  for (let i=0; i<data.length; i+=4) {
    let r=data[i], g=data[i+1], b=data[i+2], a=data[i+3];
    if(a===0) continue; // 透明ピクセルは無視

    // RGB -> HSL
    const max=Math.max(r,g,b), min=Math.min(r,g,b);
    let h=0,s=0,l=(max+min)/2/255;
    if(max!=min){
      const d=max-min;
      s=l>0.5?d/(2*255-max-min):d/(max+min);
      switch(max){
        case r:h=(g-b)/d + (g<b?6:0);break;
        case g:h=(b-r)/d+2;break;
        case b:h=(r-g)/d+4;break;
      }
      h*=60;
    }
    h=(h+hue)%360;
    s=Math.min(Math.max(s+sat/100,0),1);
    l=Math.min(Math.max(l+bright/100,0),1);

    // HSL -> RGB
    const c=(1-Math.abs(2*l-1))*s;
    const x=c*(1-Math.abs((h/60)%2-1));
    const m=l-c/2;
    let r1=0,g1=0,b1=0;
    if(h<60)[r1,g1,b1]=[c,x,0];
    else if(h<120)[r1,g1,b1]=[x,c,0];
    else if(h<180)[r1,g1,b1]=[0,c,x];
    else if(h<240)[r1,g1,b1]=[0,x,c];
    else if(h<300)[r1,g1,b1]=[x,0,c];
    else [r1,g1,b1]=[c,0,x];

    data[i]=Math.round((r1+m)*255);
    data[i+1]=Math.round((g1+m)*255);
    data[i+2]=Math.round((b1+m)*255);
  }
  ctx.putImageData(imgData,0,0);
}

// ローカル保存/読み込み
document.getElementById('saveLocal').onclick = () => {
  localStorage.setItem('pvpTexture', canvas.toDataURL());
  alert('ローカル保存完了');
};
document.getElementById('loadLocal').onclick = () => {
  const data = localStorage.getItem('pvpTexture');
  if(!data) { alert('保存データなし'); return; }
  const img = new Image();
  img.onload = () => ctx.drawImage(img,0,0,canvas.width,canvas.height);
  img.src = data;
};

// GitHubアップロード
document.getElementById('upload').onclick = async () => {
  const token = document.getElementById('token').value;
  const user = document.getElementById('user').value;
  const repo = document.getElementById('repo').value;
  const dir = document.getElementById('dir').value;
  const filename = document.getElementById('filename').value;
  const path = `${dir}/${filename}`;
  const content = canvas.toDataURL('image/png').split(',')[1];

  const res = await fetch(`https://api.github.com/repos/${user}/${repo}/contents/${path}`, {
    method: 'PUT',
    headers: { 
      'Authorization': `token ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ message:'Upload PvP texture', content })
  });
  const data = await res.json();
  console.log(data);
  alert('アップロード完了');
};
</script>

</body>
</html>
